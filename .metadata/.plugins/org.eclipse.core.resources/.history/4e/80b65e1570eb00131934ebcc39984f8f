package engine;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.math.BigInteger;

public class SequenceGenerator {
	/*
	 * P	=	constant prime number specifying max permutations of quadratic residue function
	 * This should represent the size of the code space.
	 * P is used in generateRandomPermutation() below.
	 * The value of P must satisfy P=3(mod 4)
	 * The largest prime that satisfies the above and is a valid 32-bit integer is 4,294,967,291 (4.2 billion)
	 * BigInteger class is used however, so bigger primes could be input.
	 * TODO: Figure out primes to use for whole code space. (values of P<BigInteger>)
	 */
	private static final BigInteger P = new BigInteger("4294967291");
	private static final BigInteger DIVISOR1 = new BigInteger("2");
	private static final BigInteger HALF_P = P.divide(DIVISOR1);
	/*
	 * Constants to limit the number of permutations generated in one go: 
	 */
	private static final int MIN_PERM = 250;
	private static final int MAX_PERM = 10000;
	
	// Instance variable representing current x value in code space (for quadratic residue function)
	private BigInteger _x;
	private BigInteger _codeSpace;
	private BigInteger _P;
	private BigInteger _pDivisor;
	private BigInteger _halfP;
	
	// Constructor:
	public SequenceGenerator(BigInteger x, BigInteger codeSpace) {
		_x = x;
		_codeSpace = codeSpace;
	}
	
	public ArrayList<String> getCodeList(int perm) {
		/*
		 * TODO: Implement the public method to get the code list in string form
		 * perm is the number of random unique integers to generate in one go.
		 * The function forces the returned permutation count between MIN_PERM and MAX_PERM
		 * The MIN_PERM value exists to keep the shuffled ArrayList sufficiently large to ensure
		 * good random distribution of the permutations.
		 * The MAX_PERM value sets a limit on the number of permutations to stop large values
		 * passed in error from killing the software!
		 */
		if (perm < SequenceGenerator.MIN_PERM) perm = SequenceGenerator.MIN_PERM;
		if (perm > SequenceGenerator.MAX_PERM) perm = SequenceGenerator.MAX_PERM;
		return null;
	}

	private void setPValues() {
		
	}
	
	private ArrayList<BigInteger> getShuffledBigIntList(int perm) {
		/* 
		 * value of perm is validated by the public method getCodeList and will always be between
		 * MIN_PERM and MAX_PERM
		 */
		ArrayList<BigInteger> list = new ArrayList<BigInteger>();
		ArrayList<BigInteger> shuffledList;
		BigInteger newPerm;
		
		for (int i = 0; i < perm; i++) {
			// Generate a new permutation:
			newPerm = generateRandomPermutation(this._x);
			// Add it to the list:
			list.add(newPerm);
			// And then increment x:
			this._x = this._x.add(BigInteger.ONE);
		}
		shuffledList = shuffleList(list);
		return shuffledList;
	}

	private BigInteger generateRandomPermutation(BigInteger x) {
		/* 
		 * x	=   An integer that satisfies 0 < x <= (p/2) where p is the primary seed
		 * p	=	A prime number as defined in the class constant P (see above)
		 * r	=	the remainder (quadratic residue) of the squae of x (mod P)
		 */
		BigInteger r;
		r = x.multiply(x).mod(SequenceGenerator.P);
		if (x.compareTo(SequenceGenerator.HALF_P) <= 0) {
			return r;
		} else {
			return SequenceGenerator.P.subtract(r);
		}
	}
	
	private ArrayList<BigInteger> shuffleList(ArrayList<BigInteger> list) {
		/* TODO: Add source of randomness as second argument to this function
		i.e. shuffleList(List<BigInteger> list, Random rand) */
		ArrayList<BigInteger> shuffledList = new ArrayList<BigInteger>(list);
		Collections.shuffle(shuffledList); // TODO: include random source when I implement it
		return shuffledList;		
	}
	
}
